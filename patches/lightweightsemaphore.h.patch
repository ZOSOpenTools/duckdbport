From 695d2bcbc61799367d4a3f939aaa88f037aaecc4 Mon Sep 17 00:00:00 2001
From: v1gnesh <v1gnesh@users.noreply.github.com>
Date: Fri, 26 May 2023 12:16:38 +0000
Subject: [PATCH] setup semaphore for zos, from zoslib

---
 .../concurrentqueue/lightweightsemaphore.h    | 76 +++++++++++++++++++
 1 file changed, 76 insertions(+)

diff --git a/third_party/concurrentqueue/lightweightsemaphore.h b/third_party/concurrentqueue/lightweightsemaphore.h
index 1a5c0837f3..e0c39462f7 100644
--- a/third_party/concurrentqueue/lightweightsemaphore.h
+++ b/third_party/concurrentqueue/lightweightsemaphore.h
@@ -27,6 +27,8 @@ extern "C" {
 #elif defined(__unix__)
 #include <semaphore.h>
 #include <chrono>
+#elif defined(__MVS__)
+#include <zos-semaphore.h>
 #endif
 
 namespace duckdb_moodycamel
@@ -254,6 +256,80 @@ public:
 		}
 	}
 };
+#elif defined(__MVS__)
+//---------------------------------------------------------
+// Semaphore (MVS aka z/OS)
+//---------------------------------------------------------
+class Semaphore
+{
+private:
+	sem_t m_sema;
+
+	Semaphore(const Semaphore& other) MOODYCAMEL_DELETE_FUNCTION;
+	Semaphore& operator=(const Semaphore& other) MOODYCAMEL_DELETE_FUNCTION;
+
+public:
+	Semaphore(int initialCount = 0)
+	{
+		assert(initialCount >= 0);
+		int rc = sem_init(&m_sema, 0, initialCount);
+		assert(rc == 0);
+		(void)rc;
+	}
+
+	~Semaphore()
+	{
+		sem_destroy(&m_sema);
+	}
+
+	bool wait()
+	{
+		// http://stackoverflow.com/questions/2013181/gdb-causes-sem-wait-to-fail-with-eintr-error
+		int rc;
+		do {
+			rc = sem_wait(&m_sema);
+		} while (rc == -1 && errno == EINTR);
+		return rc == 0;
+	}
+
+	bool try_wait()
+	{
+		int rc;
+		do {
+			rc = sem_trywait(&m_sema);
+		} while (rc == -1 && errno == EINTR);
+		return rc == 0;
+	}
+
+	bool timed_wait(std::uint64_t usecs)
+	{
+		struct timespec ts;
+		const int usecs_in_1_sec = 1000000;
+		const int nsecs_in_1_sec = 1000000000;
+
+		ts.tv_sec = usecs / usecs_in_1_sec;
+		ts.tv_nsec = (usecs % usecs_in_1_sec) * 1000;
+
+		int rc;
+		do {
+			rc = sem_timedwait(&m_sema, &ts);
+		} while (rc == -1 && errno == EINTR);
+		return rc == 0;
+	}
+
+	void signal()
+	{
+		while (sem_post(&m_sema) == -1);
+	}
+
+	void signal(int count)
+	{
+		while (count-- > 0)
+		{
+			while (sem_post(&m_sema) == -1);
+		}
+	}
+};
 #else
 #error Unsupported platform! (No semaphore wrapper available)
 #endif
-- 
2.39.1

